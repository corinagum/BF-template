import { Response, Server } from 'restify';
import { DirectLineTokenData } from '../../DirectLineTypes';
import generateServiceToken from '../../utils/generateServiceToken';
import setImmediateAndInterval from '../../utils/setImmediateInterval';

/**
 * Gets a list of pregenerated tokens viewable at /api/token/directline
 * Generates a new token every minute
 * Lists the latest expired token
 * Then lists all non-expired tokens
    tokensList: {
        tokens: [
          {
            message: ['token', 'expiration', 'info'],
            tokenData: {...token}
          }
        ]
      }
 *  This is for manual use, not for 'standard' bot use
 */
export default async function getTokenListDirectLine(server: Server): Promise<void> {
  const AUTOGENERATE_TOKEN_INTERVAL = 60000;

  let pregeneratedTokens: DirectLineTokenData[] = [];

  const setAutogenerated = async () => {
    const tokenResponse = await generateServiceToken();

    pregeneratedTokens.push({ ...tokenResponse });

    pregeneratedTokens = pregeneratedTokens.filter(
      token => token.expires_at > Date.now() - AUTOGENERATE_TOKEN_INTERVAL
    );
  };

  setImmediateAndInterval(setAutogenerated, AUTOGENERATE_TOKEN_INTERVAL);

  server.get('/api/token/directline', async (_, res: Response) => {
    try {
      res.set({
        'content-type': 'text/plain',
        'cache-control': 'no-cache'
      });

      res.sendRaw(
        JSON.stringify(
          {
            tokens: pregeneratedTokens.map(token => {
              const { expires_at: expiresAt } = token;
              const now = Date.now();
              const tokenExpirationString = `Token expires at ${new Date(expiresAt)}`;
              const tokenExpirationStatus =
                now > expiresAt
                  ? 'This token has expired'
                  : `This token expires in about ${(expiresAt - now) / 1000} seconds`;
              const messageSeparator = `${'-'.repeat(
                Math.max(tokenExpirationString.length, tokenExpirationStatus.length)
              )}`;

              return {
                message: [messageSeparator, tokenExpirationString, tokenExpirationStatus, messageSeparator],
                tokenData: { ...token }
              };
            })
          },
          null,
          2
        ),
        {
          'Content-Type': 'application/json'
        }
      );
    } catch (err) {
      res.send(500, { message: err.message, stack: err.stack }, { 'Access-Control-Allow-Origin': '*' });
    }
  });
}
